# golang-related-questions

**1. Что такое DDD (Domain Driven Design)? Использовали ли на практике?**

Паттерн/подход к организации разработки ПО, при котором проектировщик/архитектор
выделяет основные сущности/процессы в автоматизируемой предметной области и реализует дальнейшую бизнес-логику вокруг
них. Такой подход может быть применен в случае специфики/сложности/ограниченной информированности о домене проекта на
входе.
Пример из практики - в бизнесе компании-работодателя сформировалось новое направлении - новая логистическая модель
перевозок заказов. Шаги к реализации - создана новая схема в БД, созданы новые сервисы (сервисы на уровне слоя
бизнес-логики приложения - см список ниже), реализована базовая ожидаемая функциональность:

- `orderGroupService`
- `orderService`
- `orderItemService`

Далее сервисы указанного нового домена развиваются и постепенно обрастают новой функциональностью

**2. При каком характере нагрузки имеет смысл использовать многопоточность?**

Любой кейс, когда параллельное выполнение задач имеет практический смысл, например:
- множественнные операции ввода-вывода (сеть/файловая система), например, посетить 100 урлов
- параллельное выполнение однотипных действий, например, процессинг поступаюших в сервис задач - валидация, получение
  доп. данных во внешнем API, отправка по флоу далее в API/брокер ...
  Плохой кейс - пытаться параллелить CPU-bound задачи (сложные расчеты/обработка изображений) или же задачи, упирающиеся
  в ограниченный ресурс - БД/что-то иное.

**3. Какие накладные расходы возникают при использовании горутин?**

В начале по 2 Кб памяти на горутину в текущих версиях Go, далее стек памяти горутины может увеличиться, также при
компиляции компилятор
может принимать решение о выделении ("убегании" - escaping) некоторых объявленных объектов в кучу - отдельную область
памяти,
управляемую сборщиком мусора

**4. Что такое SAGA?**

Паттерн проектирования распределенных систем (сервисов), который позволяет получить консистентность данных в
распределенных
сервисах и обеспечивать транзакционность (передачи данных) между ними.

**5. Как реализован механизм ACID в Postgres на логическом и физическом уровне?**

Логический - поступают конкурентные параллельные запросы/транзакции в БД, Postgres выстраивает их
выполнение условно последовательно, выполняются почти параллельно, в реальности каждая последующая транзакция читает
закомиченный результат уже выполнившейся перед ней транзакции - актуально для установленного по умолчанию в Postgres
уровня изоляции транзакций `read committed`. Тут по сути описаны 2 принципа из ACID: `consistency` и `isolation`.
Физический уровень - Postgres использует механизм версионирования - MVCC - multu-version concurrency control - условно он
позволяет фиксировать изменения в новых строках и таким образом избегать конфликтов и фиксировать результаты конкурентных транзакций.
